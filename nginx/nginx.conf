events {
    # Maximum number of simultaneous connections per worker process
    # worker_connections = how many clients can connect at once
    # Default: 512, we use 1024 for better capacity
    worker_connections 1024;
}

# http block => All web server configuration
http {
    # Include MIME types
    # MIME types tell browsers what kind of file they're receiving
    # Example: text/html, application/json, image/png
    include /etc/nginx/minme.types;

    # $remote_addr = client IP
    # $time_local = timestamp
    # $request = HTTP method + path
    # $status = response code (200, 404, 500, etc.)
    # $body_bytes_sent = response size
    log_format main '$remote_addr - $remote_user [$time_local] "$request"'
                    '$status $body_bytes_sent "$http_referer"'
                    '"$http_user_agent" "$http_x_forwarded_for"'

    access_log /var/log/nginx/access.log; 
    error_log /var/log/nginx/error.log;

    # Performance Optimization
    # sendfile = efficient file transfer (nginx directly sends files without copying to buffer)
    # tcp_nopush = send headers in one packet (reduces network overhead)
    # tcp_nodelay = don't wait to send small packets (reduces latency)
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;

    # How long to keep connection open for reuse
    # 65s = good balance (too short = more overhead, too long = waste resources)
    keepalive_timeout 65;

    # Gzip compression - reduces bandwidth usage
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript 
               application/json application/javascript application/xml+rss 
               application/rss+xml font/truetype font/opentype 
               application/vnd.ms-fontobject image/svg+xml;

    # Upstream Backend Servers
    upstream fastapi_backend {
        server api:8000;
    }

    # Server Block => Main configuration for FastAPI
    server {
        listen 80;
        server_name _;

        # Setting maximum body size for client
        client_max_body_size 10M;

        location / {
            # Proxy headers - preserve original request information
            # Why these headers?
            # FastAPI needs to know the real client IP, protocol, etc.
            # Without these, FastAPI only sees nginx's IP
            
            # $host = original domain name (e.g., api.yourdomain.com)
            proxy_set_header Host $host;

            # $remote_addr = client's real IP address
            # Without this, FastAPI logs would show nginx's IP for all requests
            proxy_set_header X-Real_IP $remote_addr; 

            # $proxy_add_x_forwarded_for = chain of proxies
            # Useful if there are multiple proxies (CDN → nginx → FastAPI)
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            # $scheme = http or https
            # Tells FastAPI whether original request was secure
            proxy_set_header X_Forwarded_Proto $scheme;

            # Forward request to FastAPI backend
            # "http://fastapi_backend" refers to upstream block above
            proxy_pass http://fastapi_backend;

            # Proxy timeouts
            # How long to wait for backend response before giving up
            proxy_connect_timeout 60s;     # Time to connect to backend

            proxy_send_timeout 60s;        # Time to send request to backend

            proxy_read_timeout 60s;        # Time to read response from backend

            # Buffering settings
            # off = stream responses directly to client (good for large responses)
            # on = buffer in nginx first (good for slow clients)
            proxy_buffering on;
        }

        location /nginx-health {
            access_log off; 
            return 200 "Nginx is up and running\n";
            add_header Content-type text/plain;
        }
    }
}